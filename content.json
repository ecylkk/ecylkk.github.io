{"posts":[{"title":"JS 异步","text":"👹 Promise 用来优化回调地狱问题 使代码可读性更高 Promise方法会有两个参数，条件为真，会执行参数一，否则会执行参数二，执行参数一之后.then 否则catch数据的传递是直接用参数，并且在每个回调函数里面不能马上处理数据，需要下一个.then 或者 catch来打印。 async await async ：是用来定义此函数是一个异步函数，也只有在异步函数里才能使用await关键字 123456async function name(params) { //这是一个异步函数 let resultA = await requestResultA() let resultB = await requestResultB(resultA) console.log(resultB); } resultA返回的是一个promise await字面意思是等待 当程序执行到第一个await ，计算机需要完全将 requestResultA() 执行完才会 执行下面的代码。 假如不这样，代码会一股脑的运行到低，其中的数据压根来不及处理1234//回忆一下async function XX(){ { data : ref } = await 一个Promise返回对象} Promise 是一个异步操作，当它忙于工作时，主程序可以继续，不会阻碍进步","link":"/2022/07/29/JS%20%E5%BC%82%E6%AD%A5/"},{"title":"Markdown 补全","text":"👹 按ctrl+shift+p 输入settings.json 打开settings.json文件 🥝请留意是user那个🥝 在出现の大括号内添加如下并保存123,&quot;[markdown]&quot;: { &quot;editor.quickSuggestions&quot;: true} 🥝请留意[]前边的逗号🥝 文件👉首选项👉用户片段 输入markdown加入常用的html标签以及触发词，如下1234567891011121314151617181920212223{&quot;font-red&quot;: { //名字 &quot;prefix&quot;: &quot;red&quot;, // 设置的模板缩写 &quot;body&quot;: &quot;&lt;font color='red'&gt;$1&lt;/font&gt;$2&quot;, //模板内容，$1表示第一个光标位置，按tab光标会移动到$2,$0是最后光标位置 &quot;description&quot;: &quot;红色字体&quot; //模板描述 }, &quot;Print to console&quot;: { &quot;prefix&quot;: &quot;end&quot;, &quot;body&quot;: [ &quot;## END &quot;, &quot; &quot;, &quot;阿拉丁~神灯&quot;, &quot; &quot;, &quot;&lt;div&gt;&quot;, &quot; &lt;img alt=\\&quot;GIF\\&quot; src=\\&quot;https://springbird.oss-cn-beijing.aliyuncs.com/img/mmqrcode1632325540724.png\\&quot; width=\\&quot;280px\\&quot; /&gt;&quot;, &quot; &lt;img alt=\\&quot;GIF\\&quot; src=\\&quot;https://springbird.oss-cn-beijing.aliyuncs.com/img/qrcode_for_gh_cead8e1080d6_344.jpg\\&quot; width=\\&quot;280px\\&quot; /&gt;&quot;, &quot;&lt;/div&gt;&quot; ], &quot;description&quot;: &quot;end output&quot; }}","link":"/2022/07/11/Markdown%20%E8%A1%A5%E5%85%A8/"},{"title":"JS 闭包","text":"👹 有函数嵌套 引用局部变量 返回函数 创建一个对象变量 其实算是一种开发习惯规范，代码更简洁","link":"/2022/08/01/JS%20%E9%97%AD%E5%8C%85/"},{"title":"Python 批量修改文件名","text":"👹 起因 由于下载的视频所带的字幕命名不当，导致PotPlayer播放器无法识别对应字幕 （其实PotPlayer播放器可以设置自己模糊寻找字幕文件） 12345678910111213141516import osimport operatorlsAll = os.listdir(&quot;./&quot;)for k, v in enumerate(lsAll): if(os.path.isdir(v) == True ): path = os.getcwd()+'/'+v+'/' os.chdir(path) strlsAll = os.listdir(&quot;./&quot;) #🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝这个for循环用来给每个子文件夹重命名 for v in strlsAll: if (operator.contains(v,'.srt')): FileName, fileType = os.path.splitext(v) print(FileName) os.rename(v,FileName[:-3]+fileType) os.chdir('../') 解释一下 首先列出本文件夹中所有文件夹，程序进入第一个文件夹为符合后缀的文件命名，命名完成，程序返回上一级目录，再为第二个文件夹中的文件命名，依此类推 ChatGPT版1234567891011121314151617181920212223242526272829import osimport shutildef rename_files(): # 获取当前目录路径 current_dir = os.getcwd() # 遍历当前目录及其子目录中的所有文件夹 for root, dirs, files in os.walk(current_dir): # 遍历当前文件夹中的所有文件 for file in files: # 判断是否为视频文件或字幕文件 if file.endswith('.mp4') or file.endswith('.srt') or file.endswith('.vtt'): # 获取当前文件名的前3个字符 new_name = file[:3] # 查找当前文件夹中是否已经存在同名文件 i = 1 while os.path.exists(os.path.join(root, new_name + '_' + str(i) + os.path.splitext(file)[1])): i += 1 # 构造新的文件名 new_name = new_name + '_' + str(i) + os.path.splitext(file)[1] # 对文件进行重命名 shutil.move(os.path.join(root, file), os.path.join(root, new_name))if __name__ == '__main__': rename_files()","link":"/2022/08/06/Python%20%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%90%8D/"},{"title":"Record Shader","text":"👹 名词解释 裁剪空间 就是相机朝向视锥体的范围 从 near 到 far 流水线 应用阶段 ↓ 输出渲染图元 cpu把数据加载到显存中 设置渲染状态 draw call（命令缓冲区的一个命令） 几何阶段 ↓ 输出屏幕空间 光栅化阶段 Shader结构 Properties 数据类型 Int Float Range(float,float) Color(R,G,B,A) Vertex(X,Y,Z,W) 纹理类型 2D Cube 3D 基本结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Shader &quot;Custom/MyShader&quot; //此处用于指定你的着色器的名称以及在Shader的下栏菜单中的位置//注意不要和其他的着色器同名。{ Properties{ //着色器的输入，说白了，这里缩写的内容都会显示到材质面板上 //如果有一些参数要留给用户去调整，都要写在这里，比如材质的纹理等 _Color (&quot;Color&quot;, Color) = (1,1,1,1) _MainTex (&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quot; {} _Glossiness (&quot;Smoothness&quot;, Range(0,1)) = 0.5 _Metallic (&quot;Metallic&quot;, Range(0,1)) = 0.0 } SubShader{ /*子着色器，每个子着色器都是一个完整的功能模块， 只不过他们应对不同的显卡，有任何一个子着色器可用 该着色器就是可用的，如果所有的着色器都不可用， 则Unity会使用Fallback指定的系统着色器来进行着色器 如果你不指定任何Fallback且所有的子着色器都失效了 那么该物体的渲染就会失效*/ Tags { &quot;RenderType&quot;=&quot;Opaque&quot; //标签指示着色器只渲染不透明的物体 } LOD 100 // 渲染级别比较高 pass{ /*每个子着色器中的pass块都要执行一遍 拿锻造一柄剑来说，一个pass就像是一道加工工艺 加工工艺越多，该着色器要处理的任务也就越多 当所有的pass都完成了，我们就可以得到一柄剑了。 */ CGPROGRAM //这里是真正的着色器代码所需要编写的地方， //ShaderLab支持CG语法和GLSL语法，当然，仅仅是“语法” //其本质还是ShaderLab，如果你要使用GLSL来编写着色器 //则使用GLSLPROGRAM和ENDGLSL语法块来定义 ENDCG } } SubShader{ //针对显卡B的着色器 } Fallback&quot;Diffuse&quot; //如果上述所有的显卡都不管用，那我们就 //使用UnityShader自带的Diffuse来进行渲染} Properties内支持的属性类型 记住每句话结尾不用加; 宏 常用函数 smoothstep（f1,f2,x） 如果x&lt;f1,返回0 如果x&gt;f2,返回1 可以在f1和f2之间形成颜色平滑过渡 画一个圆圈 名词解释 1 - step函数是用来找补集，而length是半径（大概是这个意思） 为什么color要乘以incircle呢 这是因为 inCircle 是一个 0 或 1 的值。 当片元在圆内时,inCircle 为 1,此时color = fixed3(1,1,0) * 1 = fixed3(1,1,0)。所以 color 保持黄色。 当片元在圆外时,inCircle 为 0,此时color = fixed3(1,1,0) * 0 = fixed3(0,0,0)。所以 color 变成黑色。 通过与 inCircle 相乘,我们实现了一种条件选择的效果。","link":"/2023/05/20/Record%20Shader/"},{"title":"Unity 性能优化方案","text":"👹 插件 build report tool 减少Draw Call Draw Call 是指一次调用 GPU 绘制操作的过程，也可以理解为一次向 GPU 提交绘制命令的过程。每次 Draw Call 都会消耗一定的 CPU 和 GPU 资源，因此过多的 Draw Call 会导致游戏的性能下降 合批（Batching）：合批是指将多个网格渲染器（Mesh Renderer）或粒子系统（Particle System）合并成一个网格渲染器或粒子系统，从而减少 Draw Call 的数量。在 Unity 中，有两种合批方式：静态合批（Static Batching）和动态合批（Dynamic Batching）。静态合批是在编辑器中进行的，可以将多个静态网格渲染器合并为一个静态网格，从而减少 Draw Call 的数量。动态合批是在运行时进行的，可以将动态网格渲染器和粒子系统合并为一个动态网格或粒子系统，从而减少 Draw Call 的数量。 减少材质（Material）的数量：每个材质都需要一个 Draw Call 来渲染，因此减少材质的数量可以减少 Draw Call 的数量。可以将多个网格渲染器使用相同的材质，或者使用材质球（Material Property Block）来动态修改材质的属性。 使用贴图集（Texture Atlas）：贴图集是将多个小贴图合并成一个大贴图的技术，可以减少 Draw Call 的数量。在 Unity 中，可以使用 Sprite Packer 工具将多个 Sprite 合并成一个贴图集。 使用 LOD（Level of Detail）：LOD 是一种通过在不同距离下使用不同的网格来减少 Draw Call 的数量的技术。在 Unity 中，可以使用 LOD Group 组件来设置不同距离下使用的网格。 使用 GPU 实例化（GPU Instancing）：GPU 实例化是一种通过使用统一的网格和材质来渲染多个实例的技术，可以减少 Draw Call 的数量。在 Unity 中，可以使用 Material 类中的 EnableInstancing 方法来启用 GPU 实例化。 减少不必要的渲染：可以使用 Frustum Culling 和 Occlusion Culling 等技术来避免渲染不可见或被遮挡的物体，从而减少 Draw Call 的数量。 ECS框架","link":"/2023/05/20/Unity%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"},{"title":"Unity 骨骼动画","text":"👹 准备 软件 Blender、Unity 模型下载 以pmx为例 为Blender(2.9版本)安装插件 插件地址 https://github.com/GiveMeAllYourCats/cats-blender-plugin 打开Blender/Preferences/Add ons/install，找到下载的zip文件 安装好搜索Cats，记得勾选 插件显示快捷键”N” 导入模型 在Cats插件里面点击Import Model 修复材质问题 打开侧边栏Misc(应该在Cats上方)，点击Shadeless（卡通材质） 修复模型 Fix Model 点击CATS插件的Fix Model按钮，即可自动进行修复，除此之外，它还会帮我们删除多余无用的骨骼，将使用同一张贴图的节点合并为一个Mesh并重命名为Body等 导出 在Cats插件里点击Export Model 即可导出fbx fbx文件放在pmx文件同级目录中(因为贴图文件) 导入进Unity 要把fbx和贴图文件一起扔进Unity的Asset文件夹里 导出材质球 选中fbx文件，在Inspector/Materials 设置Location为Use External Materials (Legacy) 点击应用 Shader 无光照模型，直接显示贴图纹理 Unlit/Texture 基于光照的卡通渲染 项目地址 https://github.com/Sorumi/UnityToonShader 主要使用ToonMultiStepsShader.shader 导入到Unity中 将材质球改为Toon/Basic/MultiSteps 调整一下高光、阴影、渐变阈值、镜面、边缘等参数 ⭐动画绑定 模板动画获取 Mixamo https://www.mixamo.com/ 在Mixamo找到想下载的模板 点击橙色的DOWNLOAD 格式选择fbx 不包含网格(without skin) 然后DOWNLOAD 将下载的fbx文件导入到Unity里(整理好文件夹，不要乱放) 选中这个fbx文件夹，在Inspector窗口中点击Rig，把Animation Type设置为Humanoid，然后点击Apply 点击Configure，可以看到人形动画Avatar的绑定信息 ⭐现在把要被绑定的模型的Animation Type也改为Humanoid 同样点击Configure按钮，检查一下Avatar 最后一步 把动画文件拖给模型父节点，此时会自动挂一个Animator组件，设置一下Avatar对象 如果要让动画循环播放，需要把动画的Loop Time勾选上","link":"/2023/05/20/Unity%20%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB/"},{"title":"Record C#","text":"👹 重载运算符 格式 访问修饰符 static 返回类型 operator+ (参数列表) 里氏替换原则 尽量不要重写父类方法，而是尽量去扩展父类方法 重写父类方法时，输入参数可以放大，输出结果可以缩小 不要抛出新的异常 如果子类不能完整地实现父类的方法，可以抛出异常或者使用assert等方式提示 拆箱装修 避免装箱和拆箱，可以使用重载方法，泛型容器，接口12345678// 强制类型转换int i = 10;double d = (double)i; // 将整数转换为浮点数//------------------// 装箱和拆箱int j = 20;object obj = j; // 装箱：将整数转换为对象int k = (int)obj; // 拆箱：将对象转换为整数 封装 与 密封类 封装 封装：指的是将类的实现细节隐藏起来，只对外部提供必要的接口和属性，从而保证类的安全性和稳定性。封装可以通过访问修饰符（public、private、protected等）来实现。1234567891011public class MyClass{ private int myPrivateField; // 只能在类的内部访问 public int MyPublicProperty // 可以在类的外部访问 { get { return myPrivateField; } set { myPrivateField = value; } }} 密封类 使用sealed关键字修饰的类，该类不能被其他程序集继承。可以继承其他类，但只能在同一个程序集，保证类的稳定性和安全性。12345sealed class MyClass{ // class definition} 多态 virtual 关键字用于定义可以被重写但不是必须被重写的方法，而 abstract 关键字用于定义必须在子类中被重写的方法都 搭配 override 关键字 抽象类是不能被实例化的类，只能被继承。 抽象函数是指没有实现的函数，只包含函数的声明。 抽象函数必须在抽象类中定义，不能在普通类中定义。 子类必须实现抽象函数才能被实例化。 子类必须实现所有的抽象方法，否则子类也必须是抽象类。 结构体和类的区别 内存分配：结构体是值类型，它们在栈上分配内存，而类是引用类型，它们在堆上分配内存。 继承：结构体不支持继承，而类支持继承。 默认构造函数：结构体有一个默认构造函数，它会将所有成员变量初始化为默认值，而类必须显式定义构造函数。 性能：由于结构体是值类型，它们在传递和赋值时会进行复制，这可能会影响性能。 而类是引用类型，它们在传递和赋值时只是传递引用，因此性能更高。 当需要封装少量数据时，结构体更为适合，而当需要封装复杂的数据和行为时，类更为适合。 访问其他脚本数据 ⭐ static 、 GetComponent GetComponentInChildren：在子物体中查找脚本组件。 MyScript myScript = GetComponentInChildren(); FindObjectOfType：在场景中查找指定类型的第一个对象。 // 在场景中查找指定类型的第一个对象 MyScript myScript = FindObjectOfType(); FindObjectsOfType：在场景中查找指定类型的所有对象。 // 在场景中查找指定类型的所有对象 MyScript[] myScripts = FindObjectsOfType(); SendMessage：向具有指定名称的所有脚本发送消息。 // 向所有脚本发送消息 SendMessage(“MyFunction”); 补充(LINQ) 泛型约束 值类型 where 泛型字母:struct 引用类型 where 泛型字母:class 存在无参公共构造函数 where 泛型字母:new() 某个类本身或者其派生类 where 泛型字母:类名 某个接口的派生类型 where 泛型字母:接口名 另一个泛型本身或派生类型 where 泛型字母:另一个泛型字母 数据集合 需要频繁修改数据时，请使用链表，因为它允许快速插入和删除元素。 需要按位置访问元素时，请使用List，因为它提供了对元素的快速随机访问。 有一个小型数据集并且需要按索引访问元素时，请使用数组，因为它是此用例中内存效率最高的数据结构。 需要实现先进先出 （FIFO） 数据结构时，请使用Queue，因为它可以有效地从队列开头插入和删除元素。 需要实现后进先出 （LIFO） 数据结构时，请使用Stack，因为它可以有效地从堆栈顶部插入和删除元素。 Lambda常用方法 Where Select OrderBy ThenBy GroupBy Join GroupJoin 协变逆变 通常与委托和接口有关 in、out用于修饰泛型的占位符 in代表只能出现在参数 out代表只能出现在返回值 多线程 首先要被调用的函数应该先存在于内存中然后再用Thread方法开启 后台线程 后台线程相当于主线程的寄生虫，当主线程死亡，后台线程也死亡 休眠 在哪个线程里执行就休眠哪个 注意事项 如果不是死循环，不必刻意关闭 如果是有两种方案 bool开关 线程提供的方法(不建议) ⭐加锁 由于多线程数据会共享 会出现许多未知错误 使用方法 先定义一个引用类型obj 在线程执行语句块外面加lock(obj) 缺点：效率影响123lock(obj){ //code block} 预处理器 #if 可以判断数值 反射 三种获取Type的方法 变量.GetType(“要加命名空间.具体的类”); typeof(“要加命名空间.具体的类”) Type.GetType(“要加命名空间.具体的类”) 可以调用别人的代码集 Activator快速实例化 Assembly程序集类 特性继承于Attribute基类，用于给类、方法加特性 [MyCustom[Attribute](“this is a class for calculate”)] 反射 可以理解为在运行时读懂当前项目中定义的类型(类、结构体等)和成员(方法、变量等)信息,然后进行动态使用。","link":"/2023/05/20/Record%20CSharp/"},{"title":"技巧 VSCode文件的排序方式","text":"👹 VS Code是我超级喜欢的一款编辑器但是有些东西藏得比较深修改显示文件顺序文件的排序方式 👇在设置 ( 文件 → 首选项 → 设置 ) 搜索 :explorer.sortOrder 设置的左侧会出现一支小笔选择要对文件进行排序的方式 Default 默认 Mixed 混合 Files first 文件优先 Type 类型 Modified 最近修改","link":"/2022/07/28/%E6%8A%80%E5%B7%A7%20VSCode%E6%96%87%E4%BB%B6%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F/"},{"title":"Unity 画线器","text":"👹 继承了较为底层的类，重写OnPopulateMesh函数 绘制网格 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class UIGridRenderer : Graphic{ //thickness指的是边框的薄厚 public float thickness; public Vector2Int gridSize; private float width; private float height; private float cellWidth; private float cellHeight; protected override void OnPopulateMesh(VertexHelper vh) { vh.Clear(); //设置宽高(自适应头盔) width = rectTransform.rect.width; height = rectTransform.rect.height; //网格的多少 cellWidth = width / gridSize.x; cellHeight = height / gridSize.y; //这个for循环绘制所有的网格 //后面count用来找第几个点 int count = 0; for (int y = 0; y &lt; gridSize.y; y++) { for (int x = 0; x &lt; gridSize.x; x++) { DrawCell(vh, x, y, count); count++; } } } void DrawCell(VertexHelper vh, int x, int y, int index) { //迭代后的 float xPos = cellWidth * x; float yPos = cellHeight * y; UIVertex vertex = UIVertex.simpleVert; vertex.color = color; vertex.position = new Vector3(xPos, yPos); vh.AddVert(vertex); vertex.position = new Vector3(xPos, yPos+cellHeight); vh.AddVert(vertex); vertex.position = new Vector3(xPos+cellWidth, yPos+cellHeight); vh.AddVert(vertex); vertex.position = new Vector3(xPos+cellWidth, yPos); vh.AddVert(vertex); //内部の顶点 // 0--1 // | | // 2--3 // vh.AddTriangle(0,1,2); // vh.AddTriangle(2,3,0); float widthSqr = thickness * thickness; float distanceSqr = widthSqr / 2f; float distance = Mathf.Sqrt(distanceSqr); vertex.position = new Vector3(xPos+(distance), yPos+(distance)); vh.AddVert(vertex); vertex.position = new Vector3(xPos+(distance), yPos+(cellHeight-distance)); vh.AddVert(vertex); vertex.position = new Vector3(xPos+(cellWidth-distance), yPos+(cellHeight-distance)); vh.AddVert(vertex); vertex.position = new Vector3(xPos+(cellWidth-distance), yPos+(distance)); vh.AddVert(vertex); //一组内部顶点 int offset = index * 8; vh.AddTriangle(offset+0, offset+1,offset+ 5); vh.AddTriangle(offset+5, offset+4, offset+0); vh.AddTriangle(offset+1, offset+2, offset+6); vh.AddTriangle(offset+6, offset+5, offset+1); vh.AddTriangle(offset+2, offset+3, offset+7); vh.AddTriangle(offset+7, offset+6, offset+2); vh.AddTriangle(offset+3, offset+0, offset+4); vh.AddTriangle(offset+4, offset+7, offset+3); }} 请留意 变量 distance 含义是 内部矩形顶点距离外部矩形（平行线）之间的距离 变量 thickness 含义是 同一个位置外部矩形顶点和内部矩形顶点的间距","link":"/2023/03/05/Unity%20%E7%94%BB%E7%BA%BF%E5%99%A8/"},{"title":"技巧 移除右键菜单选项","text":"👹 新建一个txt文件，将以下内容粘贴进去，保存改后缀为.reg格式，运行 123Windows Registry Editor Version 5.00[-HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\AnyCode][-HKEY_CLASSES_ROOT\\Directory\\shell\\AnyCode]","link":"/2022/07/12/%E6%8A%80%E5%B7%A7%20%E7%A7%BB%E9%99%A4%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E9%80%89%E9%A1%B9/"},{"title":"技巧 Rider取消右侧白条","text":"👹 JB社的这个设计看着真的很烦人欸 按下Ctrl+Alt+S 在出现搜索框内输入👇 Show hard wrap and visual guides 将其取消勾选 即可取消界面上的白线 | 我已经不是微软粉了，现在只会尬黑微软，JB家的软件才是宇宙无敌之好用之666","link":"/2022/10/15/%E6%8A%80%E5%B7%A7%20Rider%E5%8F%96%E6%B6%88%E5%8F%B3%E4%BE%A7%E7%99%BD%E6%9D%A1/"},{"title":"技巧 桌面快捷方式变白解决办法","text":"👹 新建一个txt文件将以下内容粘贴进去，并改后缀为.bat，运行 12345@echo offtaskkill /f /im explorer.exeCD /d %userprofile%\\AppData\\LocalDEL IconCache.db /astart explorer.exe","link":"/2022/07/12/%E6%8A%80%E5%B7%A7%20%E6%A1%8C%E9%9D%A2%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E5%8F%98%E7%99%BD%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"title":"数组 二分查找法","text":"👹 问题给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标 123456789101112131415array = [1,2,3,4,5]left=0right=len(array)-1#这是目标数target = 4while left&lt;=right: mid = (left+right)//2 if target &lt; array[mid]: right = mid-1 elif target &gt; array[mid]: left = left+1 else: print(f'这个目标数的下标是⭐{mid}⭐') break 解析属于暴力解法，从第一个元素依次试出 在while循环里，首先找到中间值【//】是返回一个不大于原数（原数不巧很有可能是小数）的一个整数 第一个if，如果这个目标数小于中间值，那么说明右边界需要缩短范围，由于不包含它，所以需要减一 在第二个if中，如果目标值大于中间值，那么说明目标值在中间值的右侧，左边界需要缩短范围，由于不包含原本的界限，所以需要加一 如果都相等了，那么就会走else路线并将最终的mid输出 “是闭就沾一”左闭 left = middle + 1右闭 right = middle - 1 “两闭加等于”如果是两个闭区间while(left &lt;= right)","link":"/2023/02/27/%E6%95%B0%E7%BB%84%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/"},{"title":"算法 面试题","text":"👹 0-235 有多少个 1 ？12345678num = 0for items in range(236): for item in str(items): if item=='1': num+=1print(num) 解析： 循环从 0-235 ，因此需要填写 236 的范围 将 items 转成字符类型可以算是个数组 第二个 for 循环的 item 将检测 items 是否含有 1 如果有那么 num 将 +1 当 items 为 111 的时候相当于加了三次 改进一下👇 如果每个数字只允许出现一次呢？ 123456789101112131415161718num = 0b = Truefor items in range(0,236): for item in str(items): if item=='1' and b: num+=1 b=not b print(items,item) b=not bprint(num) 解析： 那么只需要加个布尔检测即可 字符串搜索 暴力算法 hash算法 BM算法 ⭐ 坏字符规则 好字符规则 KMP算法 ⭐","link":"/2022/12/26/%E7%AE%97%E6%B3%95%20%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"记录 FPS Zombies","text":"👹 是一篇 恐怖生存类游戏的 制作笔记 判断是否player在空中 射线检测1234567891011void Update(){ RaycastHit hitInfo; if (Physics.SphereCast(transform.position, _collider.radius, Vector3.down, out hitInfo, (_collider.height / 2f) - _collider.radius + .01f)) { Debug.Log(&quot;现在应该是接触&quot;); } Debug.Log(&quot;现在应该是空中&quot;);} 移动方案 GetAxis12345float horizontalInput = Input.GetAxis(&quot;Horizontal&quot;);float verticalInput = Input.GetAxis(&quot;Vertical&quot;);Vector3 movement = new Vector3(horizontalInput, 0, verticalInput) * speed;transform.Translate(movement); 弹夹补充方案12345678//装载所需子弹int amountNeeded = ammoClipMax - ammoClip;//一个判断：如果所需的小于子弹库就只装载所需的，如果所需大于现有的 只能全部装载咯int ammoAvailable = amountNeeded &lt; ammo ? amountNeeded : ammo;//现有的减去所需的ammo -= ammoAvailable;//装载弹夹ammoClip += ammoAvailable Terrain地图刷 Hierarchy添加Terrain地形 在笔刷下按住shift是橡皮 skybox天空盒 创建一个天空盒 要创建材料 然后选择skybox/panoramic 着色器 如果出现纹理有一道白条 将素材warp mode修改为clamp 并取消generate mip maps fog 在lighting里开启 Mode Linear ： 线性 离相机越近的物体，雾的密度越小 ⭐ Exponential ： 指数雾是一种更加真实的雾模式，它使用指数函数来控制雾的密度。离相机越远的物体，雾的密度增长速度越快 Exponential Squared ： 指数平方雾是一种更加密集的雾模式，它使用指数平方函数来控制雾的密度。离相机越远的物体，雾的密度增长速度更快，同时雾的密度也更加密集 设计 原则 就近性 相关互联的元素应该紧密放置在一起 连贯的自我风格，也就是说能让人知道这是同一个人做的，就像毕加索和莫奈的画 颜色搭配建议从 网上找配好的色盘 游戏地图布局 Open 无序挑战 Linear 起点-旅程-结束（可以藏彩蛋，或是不同结局周目） Spoke and Hub 导出包放到其他项目这将有利于简洁 选中素材 export package(一定要ctrl+s) 自动导航 烘焙 点击Terrain游戏物体，在window/AI/Navigation 选择Bake 没有烘焙到的物体需要把他们名字右边的标签设置成Navigation Static 再次Bake 包括跌落的高度 Height Mesh用来解决角色浮空，需要重新烘焙 烘焙完成后 需要为游戏物体添加一个Nav Mesh Agent组件才可以使用 导航的使用 要注意 动画播放速度 与 移动速度 的和谐123456789101112131415void Start(){ agent = GetComponent&lt;NavMeshAgent&gt;();}void Update(){ agent.SetDestination(/*一个位置*/); //判断距离停止 if(agent.remainingDistance &gt; agent.stoppingDistance){ //切换动画 等 } else{ //切换动画 等 }} 扩展角色状态机 首先考虑 状态之间的关系 一个Switch-枚举结构的判断-控制动画状态机123456789101112131415161718192021222324252627282930void Update() { switch (state) { case STATE.IDLE: state = STATE.WANDER; break; //⭐这个状态是游逛 case STATE.WANDER: if (!agent.hasPath) { float newX = transform.position.x + Random.Range(-5, 5); float newZ = transform.position.z + Random.Range(-5, 5); //这段代码的意思是获取某个Y值 因为terrain是不平的 float newY = Terrain.activeTerrain.SampleHeight(new Vector3(newX, 0, newZ)); Vector3 dest = new Vector3(newX, newY, newZ); agent.SetDestination(dest); //实时游荡 agent.stoppingDistance = 0; } break; case STATE.CHASE: break; case STATE.ATTACK: break; case STATE.DEAD: break; } } 对上面的代码改进，因为僵尸会卡住123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.AI;public class CopyCode : MonoBehaviour{ private NavMeshAgent agent; enum STATE { IDLE, WANDER, ATTACK, CHASE, DEAD }; //Default State private STATE state = STATE.IDLE; // Start is called before the first frame update void Start() { agent = GetComponent&lt;NavMeshAgent&gt;(); } float DistanceToPlayer() { //return Vector3.Distance(被追逐对象的位置，自己的位置); } bool CanSeePlayer() { if (DistanceToPlayer() &lt; 10) return true; return false; } bool ForgetPlayer() { if (DistanceToPlayer() &gt; 20) { return true; } return false; } void Update() { #region 状态机相关 switch (state) { case STATE.IDLE: if (CanSeePlayer()) { state = STATE.CHASE; } else { state = STATE.WANDER; } break; //这个状态是游逛 case STATE.WANDER: if (!agent.hasPath) { float newX = transform.position.x + Random.Range(-5, 5); float newZ = transform.position.z + Random.Range(-5, 5); //这段代码的意思是获取某个Y值 因为terrain是不平的 float newY = Terrain.activeTerrain.SampleHeight(new Vector3(newX, 0, newZ)); Vector3 dest = new Vector3(newX, newY, newZ); agent.SetDestination(dest); //实时游荡 agent.stoppingDistance = 0; /*切换动画*/ } if (CanSeePlayer()) state = STATE.CHASE; break; case STATE.CHASE: //追逐 agent.SetDestination( /*被追逐的坐标*/); agent.stoppingDistance = 5; /*切换动画 很多条件哦*/ //小于停止距离就攻击 if (agent.remainingDistance &lt; agent.stoppingDistance &amp;&amp; !agent.pathPending /*防止出现bug*/) { state = STATE.ATTACK; } if (ForgetPlayer()) { state = STATE.WANDER; agent.ResetPath(); } break; case STATE.ATTACK: /*切换动画*/ transform.LookAt( /*玩家坐标*/); if (DistanceToPlayer() &gt; agent.stoppingDistance + 2 /* 加2是因为两个状态切换 由于距离一样导致冲突 */) { state = STATE.CHASE; } break; case STATE.DEAD: break; } #endregion }} idle / wander 切换12345678910111213141516171819202122232425262728293031323334case STATE.IDLE: if (CanSeePlayer()) { state = STATE.CHASE; }//Idle / wander 的状态切换 else if (Random.Range(0, 1000) &lt; 5) { state = STATE.WANDER; } break; //这个状态是游逛case STATE.WANDER: if (!agent.hasPath) { float newX = transform.position.x + Random.Range(-5, 5); float newZ = transform.position.z + Random.Range(-5, 5);//这段代码的意思是获取某个Y值 因为terrain是不平的 float newY = Terrain.activeTerrain.SampleHeight(new Vector3(newX, 0, newZ)); Vector3 dest = new Vector3(newX, newY, newZ); agent.SetDestination(dest);//实时游荡 agent.stoppingDistance = 0;/*切换动画*/ } if (CanSeePlayer()) state = STATE.CHASE;//Idle / wander 的状态切换 else if (Random.Range(0, 1000) &lt; 5) { state = STATE.IDLE;/*清除路径和动画*/ agent.ResetPath(); } break; 生成怪物の方案123456789101112public GameObject prfb; public int num; public float spawnRadius; void Start() { for (int i = 0; i &lt; num; i++) { //挂载物体的位置 周围的随量 Vector3 randomPoint = transform.position + Random.insideUnitSphere * spawnRadius; Instantiate(prfb, randomPoint, Quaternion.identity); } } 会因为地形 将怪物生成到空中12345678910111213141516171819202122232425using UnityEngine;using UnityEngine.AI;public class Spawn : MonoBehaviour{ public GameObject prfb; public int num; public float spawnRadius; void Start() { for (int i = 0; i &lt; num; i++) { //挂载物体的位置 周围的随量 Vector3 randomPoint = transform.position + Random.insideUnitSphere * spawnRadius; NavMeshHit hit; if (NavMesh.SamplePosition(randomPoint, out hit, 10f, NavMesh.AllAreas)) Instantiate(prfb, hit.position, Quaternion.identity); else i--; } }} Ragdoll系统（avatar系统）hierarchy右键3d create ragdoll 用这个系统做了一个死亡动画 施加一个力 力的方向是相机的朝向乘以一个力度系数12345if (Input.GetKeyDow(KeyCode.P)){ GameObject rd = Instantiate(avatarPrfb); rd.transform.Find(&quot;Hips&quot;).GetComponent&lt;Rigidbody&gt;().AddForce(Camera.main.transform.forward * 一个系数);} 射击方案 指定一个枪口坐标位置 将射线发射脚本挂载到那个物件上 该挂件起名叫做Shot direction 僵尸用的是椭圆体碰撞体 hitInfo是用来存储检测返回 第一个if条件里是从以一个角度从一个点发射（有距离限制，out返回一个值） 从hitInfo里获取有用信息 比如GameObject 如果GameObject == “Zombie”，获取这个挂件上的ragdoll（本质是个有死亡动画的游戏物体） 生成这个物体，并找到Hips（这上面有刚体），给刚体一个力 造成冲击的假象 销毁原来的 补充：为了测试原地死亡和被击退死亡的对比 所以加了Random.Range函数加以对比 准心瞄准 在枪上面挂载点光源挂件 把准心图片挂载到点光源的Cookie里 Spot Range调节大小 把图片渲染模式调成clamp 只在某个图层显示 先设置怪物的图层，再在光源挂件的Culling mask选择触发图层 尸体下沉消失12//找到触发の这个点Terrain.activeTerrain.SampleHeight(transform.position); 然后摧毁collider 和 游戏物体 和 AI导航 玩家生命值相关 构成 玩家脚本 初始生命值 clamp函数限定血量计算公式，因为他这个包括加血和减血，包含一个形参 这样的好处是可以为单独的怪物设置攻击力 怪脚本 首先创建一个公共函数 获得玩家组件里的血量计算公式，并将怪自身的攻击力传进去 调用的时候是在动画系统里面调用这个，在攻击最后一帧的时候触发公共函数（可读写的动画，需要去源fbx文件复制一份动画（最好是重命名一下，因为一般都不叫attack），找到attack动画按ctrl+d拿出来，而且还要放到动画状态机里） 也就是说动画能够播放到那一帧 就扣血1player.GetComponent&lt;PlayerScript&gt;.TakeHit(damageForce); 胜利状态1234public void TakeHit(float amount){ health = (int)Mathf.Clamp(health - amount,0,maxHealth); //等生命值小于0了就可以播放动画、生成prefabs等等、胜利动画状态} GameStats 类似一个单例模式 用于记录状态 例如玩家死了 及设置false，然后加判断 就不执行某些代码了 一般来说 扩展代码 切换状态 再它们上面加if(){ /**/ return;} 是不会出什么错的 自适应UI Canvas Scaler👉UI Scale Mode 👉 Scale With Screen Size 数值溢出相关 在单例里面加个布尔判断 加个判断，并在子弹逻辑里面最后一句后面使得变成false 在动画系统里面的最后一帧（动画播放完）再调用单例里面的方法，让它变成true 雷达相关🦅 P71/P72 大致逻辑 雷达的注册脚本 注册每个对象，并存到List里，包括坐标，图标等 删除对象，创建一个新的list，就凭着变量的gameobject来，遍历来找到并销毁，再跳出本次循环，其他不是的，存进新的list，最后移出旧List所有元素，并把新list加到旧List 雷达的更新脚本 在Update里面更新，如果 遍历出distance，也即是包含了方向的一个矢量 （有个mapScale系数） 使其每个点成为雷达的子物体 并获取到RectTransform组件，给予动态的坐标，关键代码和截图如下（其中的数学逻辑挺复杂） 1ro.icon.transform.position = new Vector3( RadarPos.x + rt.pivot.x , RadarPos.z + rt.pivot.y , 0) + this.transform.position； 雷达遮罩 mask组件 医疗包、子弹显示在地图 也是类似原理，只不过换了图标（把MakeRaderObject.cs脚本挂载prefab上） 罗盘方向条🦅-P74 逻辑（是包含数学） 灯光系统 intensity 强度 反射探针 为场景中需要生成更加真实的反射效果的物体提供额外的信息支持 让火炬的阴影展现在地面上 MeshRender的Lighting的cast shadow 选成 Two sided 粒子想象成花洒 飙血效果（子弹打在身上减血） 生成一个blood，位置是打击的那个点 在射线打击会返回一个点的坐标 并让他lookAt玩家（lookAt这么好用的么） 被攻击时屏幕有受伤状态 首先有一张图片，对它进行录制透明度的过渡动画（unity也有类似PR的关键帧） 在动画状态机里会自动创建 把代码写在玩家的代码的生命计算函数里，也就是加血减血的那个，生成一个GameObject，并使得它成为Canvas的组件，并在两秒后销毁 随机产生在canvas上，首先应该拿到canvas的宽高，然后使用一个vector3的矢量（z值是0）来随机产生一个坐标给受伤动画 随机修改localscale让他产生不同大小12.rect.width;.rect.height; 音乐 免费网站 https://freesound.org/ https://flashkit.com/ Volume Rolloff 贝塞尔曲线 走动是可以感受到音量的变化的 当僵尸死了，在STATE.DEAD里应该 销毁其音源 教程里是循环遍历每个AudioSource[] ，然后将它们音量设置成0 想让僵尸，狼叫随机产生，可以直接单独写个脚本 让其随机产生 addComponent 音频渲染模式默认是2D，解决方式是加个if（bool），改变成3d，改变最大距离，并设置为子物体，并且让子物体的localPosition = Vector3.zero 粒子shader 粒子旁边呈现方块，使用新版shader渲染 particle/priority addition 后处理 P85 给相机添加 post-process layer bloom 光晕 不是很好用 depth of field 景深 （用来表示玩家心理） 按钮 关卡加载按钮点击一个事件，触发一个函数 切换场景 123public void PlayGame(){ SceneManager.LoadScene(&quot;GameLevel&quot;);} 光标隐藏 cursorIsLocked = falese 两个controller的冲突 1234//用标签find到物体if(objs.Length &gt; 1){ Destroy(gameObject);} 有时觉得构建功能完整 可以来回横跳的软件架构是一种很难的事，而且有时destroy游戏物体导致后面的逻辑无法触发也会造成冲突 调节音量 一个slider 的数值传进一个函数（float），进而改变音量 不要忘记在awake时让音量等于滑块的初始值 这样在场景切换不会导致bug，你以为很简单的逻辑其实要思考缜密，并且可以来回横跳 续命（3条命） 用一个if判断（写在Takeit方法里） 记录重生点（本身在游戏刚开始就应该记录） 销毁死亡的 生成新的 开启相机 状态恢复 存档位置保存 ontrigger方法 给僵尸增加生命值 if判断，大致逻辑 僵尸的逻辑代码里有最大生命和受伤值 每当击中僵尸.get组件里的受伤害值和最大声明，如果受伤大于最大生命，则触发之前的代码","link":"/2023/05/20/%E8%AE%B0%E5%BD%95%20FPS%20Zombies/"},{"title":"数据结构","text":"👹 这里记录一些关于数据结构相关的东西 时间空间复杂度 BigO计算的是时间和空间增长的趋势 T(n)=O(f(n)) T(n)渐进复杂度 f(n)代码执行的次数 O()表示正比例关系 时间复杂度👇 越往左越好 空间复杂度👇 越往右越不好","link":"/2022/12/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"title":"记录 一个交互效果","text":"👹 在技术栈上我用的原生JS👇 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;style&gt; * { padding: 0; margin: 0; overflow: hidden; } #box { width: 200px; height: 500px; position: relative; } #box1 { position: absolute; top: 0; width: 200px; height: 200px; background-color: aqua; } #box2 { position: absolute; top: 0; z-index: -1; width: 200px; height: 200px; background-color: pink; } #button { width: 100px; height: 50px; background-color: red; }&lt;/style&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;div id=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div id=&quot;box2&quot;&gt;(●'◡'●)😄&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;button&quot; onclick=&quot;trigger()&quot;&gt; &lt;h1 id=&quot;button1&quot;&gt;点我&lt;/h1&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; let controller = true; let speed = 20; function trigger() { let position = 0 let ele = document.getElementById(&quot;box2&quot;); if (controller) { let moving = setInterval(across, 10); document.getElementById(&quot;button1&quot;).innerHTML = &quot;放回去&quot; function across() { if (speed &lt; 200) { speed += 5 ele.style.transform = `translateY(${speed}px)` } if (speed == 200) { clearInterval(moving); } } controller = !controller console.log(controller) return } if (!controller) { let moving = setInterval(acrossBack, 10); document.getElementById(&quot;button1&quot;).innerHTML = &quot;拿出来&quot; function acrossBack() { if (speed &gt; 0) { console.log(speed); speed -= 5 ele.style.transform = `translateY(${speed}px)` } if (speed == 0) { clearInterval(moving); } } controller = !controller console.log(controller); return } }&lt;/script&gt;&lt;/html&gt;","link":"/2022/09/03/%E8%AE%B0%E5%BD%95%20%E4%B8%80%E4%B8%AA%E4%BA%A4%E4%BA%92%E6%95%88%E6%9E%9C/"},{"title":"数组 移除元素","text":"👹 leetcode 27题 考察数组的底层 双指针 O(n) 题给你一个数组 list 和一个值 var，你需要 原地 移除所有数值等于 var 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 解1234567891011121314151617def Code(): list = [1,2,3,4,3,3,3,3,5,6,7,3] var = 3 size = len(list) slow = 0 fast = 0 #快指针在for循环内 while fast&lt; size: if list[fast] != var : list[slow] = list[fast] slow+=1 fast+=1 print(list[0:slow]) return slowprint(Code()) 注定义的慢指针覆盖了原列表的元素不过列表容量仍是原来的超出该下标有一些诡异的数字出现使用list[0:slow]来获取列表正常的前部分","link":"/2023/02/28/%E6%95%B0%E7%BB%84%20%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"},{"title":"算法 排序","text":"👹 1234567891011121314#首先 需要一个乱序的数字列表list = [2,3,4,5,1,77]count = len(list)print('排序前的列表为',list)# 外层for循环是次数for i in range(count-1): #内层剩余对比的次数 for j in range(count-i-1): #如果前一个数字的大小比后一个数字大,那么就让他们两个交换位置 if list[j]&gt;list[j+1]: list[j],list[j+1] = list[j+1],list[j]print('排序好的列表为',list) 结果为升序排列 若想获得降序排列只需要将&gt;换成&lt;即可 冒泡排序 和 选择排序 大致思路假定有个数组1 9 5 3 冒泡排序 升序↓1和9比 如果1比9大 那么互换 否则9和5互换 最终9将排到最后 第二轮就不用管9了 以此类推 选择排序 降序↓有两层for循环内部for循环设定一个临时变量 先让他等于1 看是否比1大 如果比1大那么让这个临时变量取代1外部for循环 让这个临时变量 放到首或者尾部","link":"/2023/02/26/%E7%AE%97%E6%B3%95%20%E6%8E%92%E5%BA%8F/"},{"title":"记录 也只不过是赌徒罢了","text":"海边 想买一张往东的🚝票，一直往东，直到尽头·· 或许那大概是海边了，印象中的海边是沙滩和海风，但我不想去沙滩那样的海边，我想去看满是礁石的海边，不知道青岛有没有这样，大概就是我截的这张图这样的👆。如果你知道哪个地方有这样的，我俩可以坐公交或者地铁去那个地方。 你千万不要感到不好意思，你愿意出来见我，我俩一起去海边走走，聊聊天，我就很高兴啦，也都会百分百的尊重你。我会穿的干干净净的，在海边拍一些风景照，前几天我新买了个手机，我想试试搭配谷歌相机拍照是怎样的一种效果，当然，我也可以当你的专属摄影师，有一段时间我也研究过照片的构图，我想我的拍照水平应该还算可以。 是讲究人 如果饿了，你就带我去吃海鲜或者羊肉汤煎包都可以，并不需要去特别贵的地方，我请客或者我俩AA都可以🦄，整个过程应该是很轻松的，如果我给你留下一个坏印象我会很难过，我也会站在你的立场考虑，该说什么话不该说什么话我都明白，作为男孩这样是应该的。况且我又时常自诩是一个体面人儿。 关于自己以后的打算 我特想在青岛找一份和计算机相关的工作，干半年左右我就回家，届时我家里新房子也装修好了，没人打扰，适合备考考研，自己挣的钱应该也够生活了，因为我没有别的开销，至少不吸烟不喝酒，我算是把提升学历当做自己终身浪漫的事情了，如果考不上我就会一直考，只是每年会拿出几个月时间出来挣钱。 多年后我再次看到当初自己写下的东西，不禁说道“考个🔨的研究生，跟尼玛舔🐕一样，乐观人在学习编程语言，悲观人在学习外国语言。”","link":"/2022/05/20/%E8%AE%B0%E5%BD%95%20%E4%B9%9F%E5%8F%AA%E4%B8%8D%E8%BF%87%E6%98%AF%E8%B5%8C%E5%BE%92%E7%BD%A2%E4%BA%86/"},{"title":"记录 是可遇不可求🦄","text":"醒来还是会觉得一阵难过，又梦见你了。我想大概永远也不会再见着了，我知道你只想和我做好朋友，我又总是忍不住给你发消息，大概白月光就是说的就是这样的，不过想来现在连说说话都不可能，真的蛮后悔的，算起来时间都已经过去一年，也不知道有没有给我发过消息，如果你看到“对方已开启验证”，不知你是一种怎样的心情。 我俩本来永远不可能认识，是我人为地改变了命运，不过还是很高兴能遇见她 ，我也曾问过她“你是不是觉得我不是你的菜”，她回答“嗯”，我又问：“我长得不丑吧？”，她说其实蛮帅的只不过不是她喜欢的类型，或许是维护我的自尊，或许是我真的不是她喜欢的类型，总之我俩都和能感受到对方的心情，在我看来，那种关系是很舒适的，虽然每次我发消息给她，她都会回复，但总感觉缺少了点东西，这种感觉明显可以感受得到。我们之间没有什么藏着掖着的东西，有什么感受都会直接说，再后来再想找寻这种关系都没有遇着这样的，都不及她。或许再也遇不到了。 印象中的她，高高的瘦瘦的，身高大概一米七左右，长头发，头发弯弯的，皮肤白皙，喜欢穿粉色的外套 和 淡雅素青颜色的裙子，笑起来很是甜美，是真的像天使一般，写到这儿，我的心情更失落了，大概爱而不得的感受就是这样子的了，或者说友情以上，恋人未满的那种不甘。我与她是在专升本认识的，她学习也应该比我好，至少英文四级她是一次过的，据她说，她高考时英语考了130+，我问她怎么学好英语，她告诉我说其实全靠悟，搞懂每个句子是怎么构成的，一定要悟，然后背单词也是必不可少的。还有一些有趣的事情我已经记不清，但还是很荣幸能够认识这样一位人品、家教、容貌、才华兼具的女子。只能留在记忆里了，永远的白月光。 有时自己走在路上、在餐厅里看到容貌气质相似、旁边有男伴的女孩子也会感到唏嘘。也会感叹时间过得很快，害怕自己还没找到意中人就老了，每次见到自己头上多长一根白头发都会很难过。某个时刻觉得自己是在流浪，刻意找寻那种失落、孤单的感觉，情人节、中秋节都是一个人。不知道她也是否一样，不过我觉得她不是我这种人，我了解她，她是属于那种没有烦恼的人，一定在跟朋友一起吃好吃的或者男朋友一起漫步在路边的街灯下，可以想象得到那种花前月下的气氛。我也希望她能够过得幸福，因为我一直自诩为体面人。 尝试删除这段记忆，再后来见到中意的姑娘都会上去要联系方式，虽然大部分都会礼貌的给我微信，但其中不乏已经有对象的、女同性恋、海王中的海王、单身主义的、极端女权主义者的、转头就删好友的。。。我是真的没脾气😡，假如你看到这儿，不要觉得我如何如何，我想我为了完成一个夙愿，来趟这趟浑水，寻找希望，并不应该受到批判。但说实话，这也是我人为的介入，因为在命运里，我和这些人本来并没有认识的机会。在这些人里，少有把我当回事的，因此我只能默默地祈祷，并且变得坚硬。 待在出租屋里思考自己存在的意义，是应该隐忍，或许应该为自己定一个目标，或是成为某个行业的大佬，或是好好赚钱攒钱润去上学，我会一直好好过，即便一个人。 font{ background-image: linear-gradient(to right, orange, purple); -webkit-background-clip: text; color: transparent; } iframe{ text-align: center; }","link":"/2022/10/16/%E8%AE%B0%E5%BD%95%20%E6%98%AF%E5%8F%AF%E9%81%87%E4%B8%8D%E5%8F%AF%E6%B1%82/"},{"title":"记录 看过的电影","text":"👹 阿飞正传华尔街之狼肖申克的救赎小丑阿甘正传花样年华杀生同桌的你胭脂扣鬼子来了","link":"/2022/07/02/%E8%AE%B0%E5%BD%95%20%E7%9C%8B%E8%BF%87%E7%9A%84%E7%94%B5%E5%BD%B1/"},{"title":"记录 喜欢的十种颜色","text":"👹","link":"/2022/08/04/%E8%AE%B0%E5%BD%95%20%E5%96%9C%E6%AC%A2%E7%9A%84%E5%8D%81%E7%A7%8D%E9%A2%9C%E8%89%B2/"},{"title":"设计模式","text":"👹 开始当一个系统明确的引用另外一个系统的同时，就会出现耦合，所以耦合是必不可少的，但是高度的耦合会使得整个系统失去重构的活性。 ⭐工厂模式12345678910111213141516171819202122232425262728293031323334353637383940414243工厂模式（Factory Mode）是一种创建型设计模式，它提供了一种将对象的创建和使用分离的方式。通过使用工厂模式，我们可以在不暴露对象创建逻辑的同时，让客户端获得一个需要的对象实例。在Unity中，我们可以使用工厂模式来实现对象的创建和管理，例如创建敌人、道具、玩家等游戏对象。下面是一个简单的示例：首先，我们需要定义一个接口，用于描述我们要创建的对象类型：public interface IObject{ void Action();}然后，我们可以定义一个具体的实现类，实现该接口：public class Enemy : IObject{ public void Action() { Debug.Log(&quot;敌人攻击！&quot;); }}接着，我们定义一个工厂类，用于根据不同的参数创建不同的对象实例：public class ObjectFactory{ public static IObject CreateObject(string objectType) { IObject obj = null; switch(objectType) { case &quot;Enemy&quot;: obj = new Enemy(); break; // 在这里可以根据需要添加更多对象类型 default: Debug.LogError(&quot;无法创建对象：&quot; + objectType); break; } return obj; }}最后，我们可以在游戏中使用工厂类来创建对象实例：IObject obj = ObjectFactory.CreateObject(&quot;Enemy&quot;);obj.Action();这样，在不直接创建敌人对象的情况下，我们可以通过工厂类创建一个敌人实例，并调用其行为方法。这样的好处是，如果我们需要添加新的对象类型，我们可以直接在工厂类中添加对应的创建逻辑，而不需要修改客户端代码。 组合模式 零件化 把每个行为都制定成一个component，通过组合制作一个具体对象 GetComponent性能问题 避免在Update内使用 在一开始初始化 单例模式 通常做各种manager123456789101112131415161718192021222324252627282930313233// 定义一个单例类public class Singleton{ // 定义一个私有的静态字段，用于存储唯一的实例 private static Singleton _instance; // 定义一个公共的静态属性，用于获取唯一的实例 public static Singleton Instance { get { // 如果实例不存在，就创建一个新的实例 if (_instance == null) { _instance = new Singleton(); } // 返回实例 return _instance; } } // 定义一个私有的构造函数，防止外部创建实例 private Singleton() { // 初始化一些数据或逻辑 } // 定义一些公共的方法或属性，供外部访问 public void DoSomething() { // ... }} 命令模式 附加好处：可以撤销命令 观察者模式 是考察对 委托、事件 的应用 对象池模式 空间换效率、不会造成内存碎片","link":"/2023/05/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"记录 害羞の人自救手册","text":"👹 注重自己的外表。长得好看不是必需品，但穿着得体是必要的（包括合适的发型，穿着时尚，微笑） 与积极的人相处，保持积极态度，平易近人。寻找周围积极向上的人身上的特点，值得注意的是，你并不应该假装有趣，或者假装自己的方式，这样会给人留一种只会找乐子的印象，应当做自己，享受自己做的事情 找一个兴趣。什么都行（汽车、环境、最新的电视剧电影） 不要太沉默寡言。也不要成为话瘤子，试图找到二者的平衡点 有信心，留意细节。因为它是提升自己最重要的方面之一，做自己喜欢的事情会让你充满信心 相信自己，告诉自己很棒。虽然这听起来很俗气，不要因为别人的评价而分心，重要的是你亲密朋友的意见，因为他们通常是诚实和直率的，不要听那些试图让你失望的人的话 开始锻炼。这不仅会让你看起来很好，而且也能促进健康饮食，并且对您的皮肤和肤色也有好处，迈向健康的生活方式 交朋友遵循的原则是简单。找到共同点，有共同感兴趣的东西，再去结合它，可以是有趣的，有帮助的，甚至是令人振奋的 远离消极的人。消极的人出现在你的生活中是一个巨大的风险，并且随时当着你的面大发雷霆 尝试做一些有意义又富有成效的事情。想象一下，如果你是一个只会打游戏和看抖音的网络巨婴，女孩子不觉得这样的人有吸引力，为自己找到有意义的工作，做自己的喜欢的事情，不去在乎什么，有你想要追求的目标并为之努力 学会为自己说话。并始终努力做得更好 想说什么就说什么。因为没关系，只要不冒犯或者荒谬 敞开心扉也会让她敞开心扉，这是建立良好对话的关键 永远记住第一印象 很重要 请诚实，不要无礼 如果邀请的话不必去贵，豪华的地方，任何你们俩可以度过愉快时光的地方都很好 在一些看起来不错的日子里，在朋友圈上发一些照片 如果你有名声，你应该自豪的去维护它 可以轻轻地取笑她，也可以有时取笑自己，或者尝试猜测她的答案来做到这一点，一个简单的规则就是不要做任何过度的事情 确保你在她的生活中扮演了一个可以完成的角色参与，不一定要一起出去玩，但让你们了解彼此的生活中发生的事情，重点是一起体验事物，分享这些体验 支持她说的话，让她觉得你可以依靠，在她需要的时候成为她会仰望的那个人 永远不要强迫女孩做任何事情，并在这样时做你自己，将注意力放回自己身上","link":"/2022/11/19/%E8%AE%B0%E5%BD%95%20%E5%AE%B3%E7%BE%9E%E3%81%AE%E4%BA%BA%E8%87%AA%E6%95%91%E6%89%8B%E5%86%8C/"},{"title":"记录 我找不到童年写的情书","text":"👹 像电影中的桥段 ？ 结局亦是。","link":"/2021/07/07/%E8%AE%B0%E5%BD%95%20%E6%88%91%E6%89%BE%E4%B8%8D%E5%88%B0%E7%AB%A5%E5%B9%B4%E5%86%99%E7%9A%84%E6%83%85%E4%B9%A6/"}],"tags":[{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"🔥Unity🔥","slug":"🔥Unity🔥","link":"/tags/%F0%9F%94%A5Unity%F0%9F%94%A5/"},{"name":"C#","slug":"C","link":"/tags/C/"}],"categories":[{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"Record","slug":"Record","link":"/categories/Record/"},{"name":"Art","slug":"Art","link":"/categories/Art/"},{"name":"Keystone","slug":"Keystone","link":"/categories/Keystone/"},{"name":"🗑️","slug":"🗑️","link":"/categories/%F0%9F%97%91%EF%B8%8F/"}],"pages":[]}